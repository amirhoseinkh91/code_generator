<#assign childClassName = model.dtoName >
<#assign entityNameVar = model.entityName?uncap_first>
<#-- ================================================================================== -->
package ${packageName};

<#if model.generatingFieldInfoContext >
import static ir.viratech.commons.api.field_info.FieldInfoContextProvider.getFieldInfoContextInstance;
import ${model.dtoPackage}.dto.${childClassName};
</#if>
import ${model.entityPackage}.${model.entityName};

import java.util.Map;

import com.fasterxml.jackson.annotation.JsonProperty;


/**
 * A base DTO for class "${model.entityName}".
 * Do not edit this file.
 * It is an automatically generated class.
 *
 */
public abstract class ${className} extends ${model.dtoParent} {
	
	
	<#if model.generatingFieldInfoContext>
	/**
	 * 
	 * Base FieldInfoContext for "${childClassName}".
	 *
	 */
	public static abstract class Base${model.fieldInfoContextName} extends ${model.fieldInfoContextParent} {
		
		
		// =========== BEGIN createFieldInfo methods ===========
		
		
		<#list model.dtoProperties as dtoProperty>
		<#assign sepLine = dtoProperty.fieldInfoEnabled >
		<#if dtoProperty.categoryKey == "primitive" >
		<#assign createFieldInfoMethodSignature>ir.viratech.commons.api.search.field.PrimitiveFieldInfo<?> createFieldInfo_${dtoProperty.name?cap_first}(
				String externalName, String internalName, String internalSearchExpression, String typeKey, String bundleKey, boolean searchable, Boolean sortable)</#assign>
		<#assign createFieldInfoMethodJavaDoc>/**
		 * creates a PrimitiveFieldInfo for primitive property "${dtoProperty.name}".
		 * @param externalName the external name of the property in the DTO class
		 * @param internalName the internal name of the property in the entity class
		 * @param internalSearchExpression the internal search expression by which the property could be really searched
		 * @param typeKey a key showing the type of the property (used in client side) 
		 * @param bundleKey Used for i18n translation of the property
		 * @param searchable true if the property could be accessed in client search queries
		 * @param sortable true if the property could be used for sorting in client search queries
		 * @return the FieldInfo created for the property
		 */</#assign>
		<#if dtoProperty.fieldInfoStyle! == "simple">
		${createFieldInfoMethodJavaDoc}
		protected ${createFieldInfoMethodSignature} {
			return new ${dtoProperty.fieldInfoType}(externalName, internalName, internalSearchExpression, typeKey, bundleKey, searchable, sortable);
		}
		
		</#if>
		<#if dtoProperty.fieldInfoStyle! == "abstract">
		${createFieldInfoMethodJavaDoc}
		protected abstract ${createFieldInfoMethodSignature};
		
		</#if>
		</#if>
		<#if dtoProperty.categoryKey == "dto" >
		<#-- ================== entityByDtoFinder material ================ -->
		<#assign entityByDtoFinderType >ir.viratech.commons.api.search.EntityByDtoFinder<${dtoProperty.internalType}, ${dtoProperty.type}></#assign>
		<#if dtoProperty.entityByDtoFinderEnabled >
		<#assign sepLine = true >
		<#if dtoProperty.entityByDtoFinderStyle == "abstract" >
		/**
		 * Creates an EntityByDtoFinder for the DTO property "${dtoProperty.name}".
		 * The created object finds entities of type "${dtoProperty.internalType}" 
		 * by DTO's of type "${dtoProperty.type}".
		 * @return the created EntityByDtoFinder
		 */
		protected abstract ${entityByDtoFinderType} ${dtoProperty.entityByDtoFinderCreatorName}();
		
		</#if>
		<#-- TODO add other implementations of createEntityByDtoFinder method -->
		private ${entityByDtoFinderType} ${dtoProperty.entityByDtoFinderFieldName};
		
		/**
		 * Getter for the previously created EntityByDtoFinder for property "${dtoProperty.name}".
		 * @return the previously created EntityByDtoFinder object 
		 */
		public final ${entityByDtoFinderType} ${dtoProperty.entityByDtoFinderGetterName}() {
			return this.${dtoProperty.entityByDtoFinderFieldName};
		}
		
		/**
		 * Finds entities of type "${dtoProperty.internalType}" 
		 * by DTO's of type "${dtoProperty.type}".
		 * It is targeted for the DTO property: ${dtoProperty.name}
		 * @param ${dtoProperty.name_DtoSuggested} 
		 *		the given dto by which the entity should be found
		 * @return the found entity
		 * @throws ir.viratech.commons.api.search.InvalidDtoException
		 * 		If the given dto is not valid or is not representing an internal entity
		 */
		public final ${dtoProperty.internalType} ${dtoProperty.findByDtoMethodNameInFIC}(${dtoProperty.type} ${dtoProperty.name_DtoSuggested}) throws ir.viratech.commons.api.search.InvalidDtoException {
			return this.${dtoProperty.entityByDtoFinderGetterName}().findByDto(${dtoProperty.name_DtoSuggested});
		}
		
		</#if>
		<#-- =================== createFieldInfo material ================= -->
		<#assign createFieldInfoMethodSignature>ir.viratech.commons.api.search.field.DtoFieldInfo<${dtoProperty.internalType}, ${dtoProperty.type}> createFieldInfo_${dtoProperty.name?cap_first}(
				String externalName, String internalName, String internalSearchExpression, String bundleKey, boolean searchable, 
				ir.viratech.commons.api.search.field.FieldInfoContext<${dtoProperty.type}> fieldInfoContext, 
				${entityByDtoFinderType} entityByDtoFinder)</#assign>
		<#assign createFieldInfoMethodJavaDoc>/**
		 * creates a DtoFieldInfo for dto-property "${dtoProperty.name}".
		 * @param externalName the external name of the property in the DTO class
		 * @param internalName the internal name of the property in the entity class
		 * @param internalSearchExpression the internal search expression by which the property could be really searched
		 * @param bundleKey Used for i18n translation of the property
		 * @param searchable true if the property could be accessed in client search queries
		 * @param fieldInfoContext the FieldInfoContext of the dto-property: ${dtoProperty.name}
		 * @param entityByDtoFinder the EntityByDtoFinder for the dto-property: ${dtoProperty.name}
		 * @return the FieldInfo created for the property
		 */</#assign>
		<#if dtoProperty.fieldInfoStyle! == "simple">
		${createFieldInfoMethodJavaDoc}
		protected ${createFieldInfoMethodSignature} {
			return new ir.viratech.commons.api.search.field.types.FieldInfo_Dto<${dtoProperty.internalType}, ${dtoProperty.type}>(
						externalName, internalName, internalSearchExpression, bundleKey, searchable, fieldInfoContext, entityByDtoFinder);
		}
		
		</#if>
		<#if dtoProperty.fieldInfoStyle! == "abstract">
		${createFieldInfoMethodJavaDoc}
		protected abstract ${createFieldInfoMethodSignature};
		
		</#if>
		</#if>
		<#if sepLine>
		
		</#if>
		</#list>
		// =========== END createFieldInfo methods ===========
		
		/**
		 * The default constructor for Base${model.fieldInfoContextName}.
		 */
		protected Base${model.fieldInfoContextName}() {
			<#list model.dtoProperties as dtoProperty>
			<#if dtoProperty.fieldInfoDisabled >
			//Disabled fieldInfo for property: ${dtoProperty.name}
			<#else>
			<#if dtoProperty.categoryKey == "primitive" >
			this.putFieldInfo(this.createFieldInfo_${dtoProperty.name?cap_first}("${dtoProperty.name}", "${dtoProperty.internalName}", "${dtoProperty.searchExpression}", ${dtoProperty.quotedTypeKey}, "${dtoProperty.bundleKey}", ${dtoProperty.searchable?c}, ${dtoProperty.sortableString}));
			</#if>
			<#if dtoProperty.categoryKey == "dto" >
			<#if dtoProperty.entityByDtoFinderEnabled >
			<#assign entityByDtoFinder >this.${dtoProperty.entityByDtoFinderGetterName}()</#assign>
			this.${dtoProperty.entityByDtoFinderFieldName} = ${dtoProperty.entityByDtoFinderCreatorName}();
			<#else>
			<#assign entityByDtoFinder >null</#assign>
			</#if>
			this.putFieldInfo(this.createFieldInfo_${dtoProperty.name?cap_first}("${dtoProperty.name}", "${dtoProperty.internalName}", "${dtoProperty.searchExpression}", "${dtoProperty.bundleKey}", ${dtoProperty.searchable?c}, 
					getFieldInfoContextInstance(${dtoProperty.fieldInfoContextClassName}), ${entityByDtoFinder}));
			</#if>
			</#if>
			</#list>
		}
		
		/**
		 * Creates a DTO of type "${childClassName}".
		 *
		 * @return the created DTO
		 */
		@Override
		public ${childClassName} createDto() {
			return new ${childClassName}();
		}
		
	}
	
	/**
	 * Provides the corresponding FieldInfoContext of this DTO.
	 *
	 * @return the corresponding FieldInfoContext object
	 */
	public ${childClassName}.${model.fieldInfoContextName} getFieldInfoContext() {
		return getFieldInfoContextInstance(${childClassName}.${model.fieldInfoContextName}.class);
	}
	</#if>
	
	
	
	
	////////////////////
	// DTO Properties //
	////////////////////
	
	<#list model.dtoProperties as dtoProperty>
	// ${dtoProperty.name}
	
	<#--  ==============  fields  ================ -->
	<#assign modName = "__modified__"+dtoProperty.name?cap_first>
	private ${dtoProperty.type} ${dtoProperty.name};
	<#if dtoProperty.trackingModifications>
	private boolean ${modName} = false;
	</#if>
	
	<#--  ==============  getter  ================ -->
	<#if dtoProperty.getterEnabled >
	/**
	 * Getter for property "${dtoProperty.name}".
	 *
	 * @return the value of property "${dtoProperty.name}"
	 */
	<#if dtoProperty.propertyAnnothationNeededInGetter>
	@JsonProperty
	</#if>
	public ${dtoProperty.type} ${dtoProperty.dtoGetterName}() {
		return this.${dtoProperty.name};
	}
	
	</#if>
	<#--  ==============  setter  ===============  -->
	<#if dtoProperty.setterEnabled >
	/**
	 * Setter for property "${dtoProperty.name}".
	 *
	 * @param ${dtoProperty.name} the new value for property "${dtoProperty.name}"
	 */
	<#if dtoProperty.propertyAnnothationNeededInSetter>
	@JsonProperty
	</#if>
	public void ${dtoProperty.dtoSetterName}(${dtoProperty.type} ${dtoProperty.name}) {
		<#if dtoProperty.trackingModifications>
		this.${modName} = true;
		</#if>
		this.${dtoProperty.name} = ${dtoProperty.name};
	}
	
	</#if>
	<#--  ============  hasModified  =============  -->
	<#if dtoProperty.trackingModifications>
	/**
	 * Shows the modification state of the property "${dtoProperty.name}".
	 * 
	 * @return true if the property is modified
	 */
	public boolean hasModified${dtoProperty.name?cap_first}() {
		return this.${modName};
	}
	
	</#if>
	<#--  ==============  loader  ===============  -->
	<#assign loadMethodSignature>${dtoProperty.type} load_${dtoProperty.name?cap_first}(${model.entityName} ${entityNameVar})</#assign>
	<#assign loadMethodJavaDoc>/**
	 * Used for loading the property ${dtoProperty.name} from a given internal entity.
	 * 
	 * @param ${entityNameVar} the given internal entity
	 * @return the value of property ${dtoProperty.name} based on the given internal entity
	 */</#assign>
	<#if dtoProperty.loadStyle! == "hooked-cast">
	${loadMethodJavaDoc}
	protected ${loadMethodSignature} {
		return (${dtoProperty.type}) (${entityNameVar}.${dtoProperty.internalGetterName}());
	}
	
	</#if>
	<#if dtoProperty.loadStyle! == "hooked-dtoLoadFrom">
	${loadMethodJavaDoc}
	protected ${loadMethodSignature} {
		${dtoProperty.internalType} ${dtoProperty.specializedInternalName} = ${entityNameVar}.${dtoProperty.internalGetterName}();
		if (${dtoProperty.specializedInternalName} == null)
			return null; 
		<#assign dto = dtoProperty.name >
		${dtoProperty.type} ${dto} = new ${dtoProperty.type}();
		${dto}.loadFrom(${dtoProperty.specializedInternalName});
		return ${dto};
	}
	
	</#if>
	<#if dtoProperty.loadStyle! == "hooked-constructor">
	${loadMethodJavaDoc}
	protected ${loadMethodSignature} {
		return new ${dtoProperty.type}(${entityNameVar}.${dtoProperty.internalGetterName}());
	}
	
	</#if>
	<#if dtoProperty.loadStyle! == "abstract">
	${loadMethodJavaDoc}
	protected abstract ${loadMethodSignature};
	
	</#if>
	<#--  ==============  saver  ===============  -->
	<#if dtoProperty.categoryKey == "dto" >
	<#assign savePropName>${dtoProperty.name_DtoSuggested}</#assign>
	<#else>
	<#assign savePropName>${dtoProperty.name}</#assign>
	</#if>
	<#assign saveMethodSignature>void save_${dtoProperty.name?cap_first}(${model.entityName} ${entityNameVar}, ${dtoProperty.type} ${savePropName})
			throws ir.viratech.commons.api.entity_modifier.BadDtoEntityModificationException</#assign>
	<#assign saveMethodJavaDoc>/**
	/**
	 * Used for saving a given value of property ${dtoProperty.name} to a given internal entity.
	 * 
	 * @param ${entityNameVar}
	 * 		the given internal entity
	 * @param ${savePropName} 
	 * 		the value of property ${dtoProperty.name} which should be saved to the given internal entity
	 * @throws ir.viratech.commons.api.entity_modifier.BadDtoEntityModificationException 
	 * 		if the given value of property ${dtoProperty.name} is not appropriate for saving the entity
	 */</#assign>
	<#if dtoProperty.saveStyle! == "abstract">
	${saveMethodJavaDoc}
	protected abstract ${saveMethodSignature};
	
	</#if>
	<#if dtoProperty.saveStyle! == "hooked">
	${saveMethodJavaDoc}
	protected ${saveMethodSignature} {
		${entityNameVar}.${dtoProperty.internalSetterName}((${dtoProperty.internalType}) ${savePropName});
	}
	
	</#if>
	<#if dtoProperty.saveStyle! == "hooked-dtoSaveTo-ignoreNull">
	${saveMethodJavaDoc}
	protected ${saveMethodSignature} {
		if (${savePropName} == null) {
			//Ignored
		} else {
			${savePropName}.saveTo(${entityNameVar}.${dtoProperty.internalGetterName}());
		}
	}
	
	</#if>
	<#if dtoProperty.saveStyle! == "hooked-dtoSaveTo-notNull">
	${saveMethodJavaDoc}
	protected ${saveMethodSignature} {
		if (${savePropName} == null) {
			throw new ir.viratech.commons.api.entity_modifier.BadDtoEntityModificationException("The given dto must not be null.");
		} else {
			${savePropName}.saveTo(${entityNameVar}.${dtoProperty.internalGetterName}());
		}
	}
	
	</#if>
	<#if dtoProperty.saveStyle! == "hooked-dtoSaveTo-nullable">
	${saveMethodJavaDoc}
	protected ${saveMethodSignature} {
		if (${savePropName} == null) {
			${entityNameVar}.${dtoProperty.internalSetterName}(null);
		} else {
			${savePropName}.saveTo(${entityNameVar}.${dtoProperty.internalGetterName}_Created());
		}
	}
	
	</#if>
	<#if dtoProperty.saveStyle! == "hooked-replaceEntity-notNull">
	${saveMethodJavaDoc}
	protected ${saveMethodSignature} {
		if (${savePropName} == null)
			throw new ir.viratech.commons.api.entity_modifier.BadDtoEntityModificationException("The given dto must not be null.");
		${dtoProperty.internalType} ${dtoProperty.specializedInternalName} = null;
		try {
			${dtoProperty.specializedInternalName} = ${dtoProperty.findByDtoMethodNameInDto}(${savePropName});
		} catch (ir.viratech.commons.api.search.InvalidDtoException e) {
			throw new ir.viratech.commons.api.entity_modifier.BadDtoEntityModificationException("The given dto is invalid: "+${savePropName}, e);
		}
		if (${dtoProperty.specializedInternalName} == null)
			throw new ir.viratech.commons.api.entity_modifier.BadDtoEntityModificationException("No entity was found for the given dto: "+${savePropName});
		${entityNameVar}.${dtoProperty.internalSetterName}(${dtoProperty.specializedInternalName});
	}
	
	</#if>
	<#if dtoProperty.saveStyle! == "hooked-replaceEntity-nullable">
	${saveMethodJavaDoc}
	protected ${saveMethodSignature} {
		${dtoProperty.internalType} ${dtoProperty.specializedInternalName} = null;
		if (${savePropName} != null) {
			try {
				${dtoProperty.specializedInternalName} = ${dtoProperty.findByDtoMethodNameInDto}(${savePropName});
			} catch (ir.viratech.commons.api.search.InvalidDtoException e) {
				throw new ir.viratech.commons.api.entity_modifier.BadDtoEntityModificationException("The given dto is invalid: "+${savePropName}, e);
			}
			if (${dtoProperty.specializedInternalName} == null)
				throw new ir.viratech.commons.api.entity_modifier.BadDtoEntityModificationException("No entity was found for the given dto: "+${savePropName});
		}
		${entityNameVar}.${dtoProperty.internalSetterName}(${dtoProperty.specializedInternalName});
	}
	
	</#if>
	<#if dtoProperty.categoryKey == "dto" && dtoProperty.findByDtoEnabled >
	<#assign findByDtoMethodSignature>${dtoProperty.internalType} ${dtoProperty.findByDtoMethodNameInDto}(${dtoProperty.type} ${dtoProperty.name_DtoSuggested}) throws ir.viratech.commons.api.search.InvalidDtoException</#assign>
	<#assign findByDtoMethodJavaDoc>/**
	 * Finds entities based on the DTO property "${dtoProperty.name}".
	 * It finds entities of type "${dtoProperty.internalType}" 
	 * based on DTO's of type "${dtoProperty.type}",
	 * targeted on the DTO property "${dtoProperty.name}".
	 * 
	 * @param ${dtoProperty.name_DtoSuggested} 
	 *		the given dto by which the entity should be found
	 * @return the found entity
	 * @throws ir.viratech.commons.api.search.InvalidDtoException
	 * 		If the given dto is not valid or is not representing an internal entity  
	 */</#assign>
	<#if dtoProperty.findByDtoStyle == "abstract" >
	${findByDtoMethodJavaDoc}
	protected abstract ${findByDtoMethodSignature};
	
	</#if>
	<#if dtoProperty.findByDtoStyle == "useContext" >
	${findByDtoMethodJavaDoc}
	protected ${findByDtoMethodSignature} {
		return this.getFieldInfoContext().${dtoProperty.findByDtoMethodNameInFIC}(${dtoProperty.name_DtoSuggested});
	}
	
	</#if>
	</#if>
	<#--  =============  toString  ==============  -->
	<#assign toStringMethodSignature>String toString_${dtoProperty.name?cap_first}(${dtoProperty.type?cap_first} ${dtoProperty.name})</#assign>
	<#assign toStringMethodJavaDoc>/**
	 * Used for converting a given value of property ${dtoProperty.name} to a developer-friendly String.
	 * @param ${dtoProperty.name} the given value of property ${dtoProperty.name}
	 * @return the developer-friendly String representation of ${dtoProperty.name}
	 */</#assign>
	<#if dtoProperty.toStringStyle! == "hooked">
	${toStringMethodJavaDoc}
	protected ${toStringMethodSignature} {
		return ${dtoProperty.name};
	}
	
	</#if>
	<#if dtoProperty.toStringStyle! == "abstract">
	${toStringMethodJavaDoc}
	protected abstract ${toStringMethodSignature};
	
	</#if>
	
	</#list>
	
	/////////////////////////
	// save/load functions //
	/////////////////////////
	
	/**
	 * Loads this DTO from an entity object of type "${model.entityName}".
	 * 
	 * @param ${entityNameVar} the entity object from which this DTO is loaded. 
	 */
	@Override
	public void loadFrom(${model.entityName} ${entityNameVar}) {
		<#list model.dtoProperties as dtoProperty>
		<#if dtoProperty.loadDisabled >
		//Disabled load for property: ${dtoProperty.name}
		<#else>
		<#if dtoProperty.loadStyle! == "simple" >
		this.${dtoProperty.name} = ${entityNameVar}.${dtoProperty.internalGetterName}();
		<#else>
		this.${dtoProperty.name} = this.load_${dtoProperty.name?cap_first}(${entityNameVar});
		</#if>
		</#if>
		</#list>
	}
	
	/**
	 * Saves this DTO to an entity object of type "${model.entityName}".
	 * 
	 * @param ${entityNameVar} the entity object to which this DTO is saved. 
	 * @throws BadDtoEntityModificationException If this DTO is not valid for saving. 
	 */
	@Override
	public void saveTo(${model.entityName} ${entityNameVar}) throws ir.viratech.commons.api.entity_modifier.BadDtoEntityModificationException {
		<#list model.dtoProperties as dtoProperty>
		<#if dtoProperty.saveDisabled >
		//Disabled save for property: ${dtoProperty.name}
		<#else>
		<#if dtoProperty.trackingModifications>
		<#assign indent = "	">
		if (this.hasModified${dtoProperty.name?cap_first}()) {
		<#else>
		<#assign indent = "">
		</#if>
		<#if dtoProperty.saveStyle! == "simple" >
		${indent}${entityNameVar}.${dtoProperty.internalSetterName}(this.${dtoProperty.name});
		<#else>
		${indent}this.save_${dtoProperty.name?cap_first}(${entityNameVar}, this.${dtoProperty.name});
		</#if>
		<#if dtoProperty.trackingModifications>
		}
		</#if>
		</#if>
		</#list>
	}
	
	
	
	//////////////
	// toString //
	//////////////
	
	@Override
	protected Map<String, Object> toStringData() {
		Map<String, Object> data = super.toStringData();
		<#list model.dtoProperties as dtoProperty>
		<#if dtoProperty.toStringStyle! == "omitted">
		//Disabled toString for property: ${dtoProperty.name}
		<#else>
		<#if dtoProperty.toStringStyle! == "value" >
		data.put("${dtoProperty.name}", this.${dtoProperty.name});
		<#elseif dtoProperty.toStringStyle! == "hooked" || dtoProperty.toStringStyle! == "abstract">
		data.put("${dtoProperty.name}", this.toString_${dtoProperty.name?cap_first}(this.${dtoProperty.name}));
		</#if>
		</#if>
		</#list>
		return data;
	}
	
}
